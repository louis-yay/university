### Concept fichier 
Le système **Unix** à une philosophie "tel un fichier", on a donc:
- Les fichiers normaux
	- Le terminal
	- Les périphériques (souris, clavier)
	- Les sockets réseaux
	- Etc...

> [!example] Définition
> Un fichier est une liste continue d'octet d'une longue connue (pas forcément fixe)


### API de gestion de fichier
Avant la lecture d'un fichier, il est nécessaire de **l'ouvrir** afin d'effectuer des vérifications d'accès
- Le programme à le droit de traverser tout les dossier jusqu'au fichier (droit `x`)
- Le programme à le droit de lier le fichier (droit `r`)

> [!warning] Droits
> En fonction de ce qui est demandé en accès à l'ouverture du fichier (lecture, écriture, etc...). Le kernel va vérifier les droits nécessaires de la même manière.

### Ouverture d'un fichier en C
```c
int fb = open (filename, O_RDONLY);

// Affiche une erreur si le programme rencontre un problème
// Personalise le message en fct de l'erreur
if (fd == -1){
	perror("open");
}
```

Par défaut pour le premier fichier de lecture, `open` va renvoyer 3.
- Le programme conserve une table correspondant aux fichiers déjà ouvert, en début de programme, la machine à déjà 3 fichiers ouverts aux index:
	- `0: STDIN_FILENO`
	- `1: STDOUT_FILENO`
	- `2: STDERR_FILENO`

TODO: IMAGE EXEMPLE


### Lire depuis un fichier en C
```c
#define BUFERSIZE 4

void lire(int fb){
	char buffer[BUFERSIZE +1];
	
	int n = read (fb, buffer, BUFERSIZE);
	buffer[n] = 0
	if (n == -1){
	perror("lecture");
	}
	
	printf("Read return %d\n", n);
	printf("octets lu: %s", buffer);
}



int fb = open (filename, O_RDONLY)
if (fd == -1){
	perror("open");
}
```

### Lire depuis le clavier
```c
int main(int argc, char* argv[]){
	if argc > 1{
		if argv[1] == '-'{
			fd = STDIN_FILENO;	
		} else{
			filename = argv[1];
		}
	}
	
	if fd == -1{
		// On lit depuis un fichier
	}
}
```


### Lire et écrire en entrée standard
```c
#define BUffERSIZE 16

void recopier(void){
	char buffer[BUFFERSIZE];
	int n;
	
	do{
		n = read(STDIN_FILENO, buffer, BUFFERSIZE);
		
		check_syscall(n, "read");
		
		write(STDOUT_FINELO, buffer, n);
	}
	while(n != 0);
}
```

> [!warning] Attention
> On peut écrire directement en lisant les valeurs depuis l'adresse mémoire de notre donnée.
> Cependant, la convention d'écriture d'une machine à l'autre est différente, il vaut donc mieux formater nos caractères.