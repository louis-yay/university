### Déplacer dans les registres
- `rrmovl` registre to register move long
- `mrmovl` memory to register move long
- `rmmovl` register to memory move long

> [!tip]
> On peut ajouter un `i` devant chaque commande pour la rendre 'imédiate'
> - On peut effectuer une opération avec un chiffre directement
> - On peut placer un coéficient devant l'étiquette de l'emplacement mémoire pour décaler l'écriture de n octets plus loins `rmmovl %eax, 4(a)`

### Instructions
- `addl [a] [b]` additionne les données des registres 
- `subl [a] [b]` soustrait les données des registres 
- `andl [a] [b]` effectuer une opération `and` entre `[a]` et `[b]`
- `xorl [a] [b]` effectuer une opération `xor` entre `[a]` et `[b`

### Flags
Il y a trois flag qui sont **CONSTAMMENT** mis à jour et indique des informations sur la dernière instruction exécuté:
- SF (« sign flag ») (1 for neg & 0 for pos) 
- ZF (« zero flag ») (1 for true & 0 for false)
- OF (« overflow flag ») (1 for true & 0 for false)

### Sauts conditionnels 
Les sauts conditionnels évaluent l'états des flags de l'opération précédente et effectue un saut en fonction.
- `jle` (Ra <= Rb): Jump if lower or equal (S^O = 1) ou (Z=1)
- `jl` (Ra < Rb): Jump if lower (S^O = 1)
- `je` (Ra = Rb): Jump if equal (Z=1)
- `jne` (Ra != Rb): Jump if not equal (Z=0)

> [!Example]
> ```c
>        .pos 0
> prog:   rrmovl %ecx, %ebx
>         andl %eax, %ebx
>         je suite
>         subl %eax, %ecx
>         halt
>        
>suite:  addl %eax, %ecx
>         halt
>
>```
>Si %eax et %ecx sont égaux alors on additionne dans ecx, sinon on soustrait dans ecx
