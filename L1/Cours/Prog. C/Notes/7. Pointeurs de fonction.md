### Motivations
La manipulation de fonction sous forme d'objet permet:
- Une réutilisation du code
- Créer de nouvelles fonctions
- Effectuer les même opérations sur tout les éléments d'une structure de données.
- **En C on ne peut pas manipuler les fonctions sous forme d'object, alors on utilise des pointeurs vers des fonctions.**
	- Les fonctions étant stocké dans la mémoire, on peut y accéder grace à des pointeurs

### Définition 
```c
typeDeRetour (*nom) (param);

int (*multiply) (int, int); // Exemple
```

Exemple d'utilisation
```c
int times(int a, int b){
	return a*b;
}

int (*multiply) (int, int); // On définit la variable
multiply = &times;
printf("%d.\n", (*multiply)(2,3)); // 6
```

Remarque:
On peut simplifier le format d'écriture:
```c
multiply = times; // Eq multiply = &times;
multiply(3,2); // Eq (*multiply)(3,2);
```
*Cependant, on perd en lisibilité ou déterminer ce qui est un pointeur de fonction et ce qui ne l'est pas.*
> [!important]
> Il est demandé d'utiliser la notation complète afin de facilité la lisibilité par l'humain

### Application en paramètre de fonction
Gestion de paramètre de la fonction d'appel:
```c
// On déclare notre pointeur de fonction
returnType (*name) (parameters);
int applyFunOnMax(int a, int b, int (*p)(int)){
	if(a > b){
		return (*p) (a);
	}
	return (*p) (b);
}
```

On peut également passer des refs de fonction en paramètre de cette façon:
```c
int times(int a, int b){
	return a+b;
}

int main(void){
	int a = applyFunOnMax(2, 3, &times);
	printf("%d", a);
	return EXIT_SUCCESS;
}
```

#### Exercice
On suppose 2 fonctions `float f1 (float) et float f2 (float)`, on veut effectuer f1(f2(e)) sur tout élément e du tableau.
```c
void applyOnArray(float (*p)(float), float* tab, int n){
	for(int i = 0; i<n; i++){
		tab[i] = (*p)(tab[i]);
	}
}
int main(void){
	int n = 100;
	float* t = malloc(n*sizeof(float));
	if ( t == NULL ) return EXIT_FAILURE;
	for(int i = 0; i<n; i++){
		t[i] = 0;
	}
	applyOnArray(&f2, t, n);
	applyOnArray(&f1, t, n);
	for(int i = 0; i<n; i++){
		printf("%.2f ", t[i]);
	}
	return EXIT_SUCCESS;
}
```

### Renvoyer un pointeur de fonction
On veut retourner une fonction de type `char (*p) (long)`  et on a un `int` en paramètres la syntaxe:
```c
char (*fname(int pname)) (long)
```

Exemple pour une fonction charToFun qui renvoie un pointeur vers une fonction qui renvoie un `int` et prend `(int, int)`
```c
int (*charToFun(char op)) (int, int);
```

#### Exercice
```c
int (*func(int (*p) (int))) (int);
```

### typedef
On peut simplifier l'écriture en faisant un typedef, par exemple pour une fonction qui renvoie un int et prend un int:
```c
typedef int (*intToInt) (int);
intToInt f (intToInt p) // La fonction précédent
```

#### Exercice
```c
int func(int tab[], int n, (*meilleur)(int, int)){
	int index = 0;
	for(int i=1; i<n; i++){
		if((*meilleur)(tab[i], t[index])){
			index = i;
		}
	}
	return index;
}

bool max(int a, int b){
	return a>b;
}

bool min(int a, int b){
	return b>b;
}

bool pair(int a, int b){
	return a%2 == 0
}
```

### Pointeur générique de fonction
On peut définir un pointeur de fonction générique, tel que les paramètres sont générique.
```c
int (*foo)(int, int);
int (*bar)(char, char, double);
int (*p)();

p = foo; // Ok
p= fee; // Ok
foo = p; // Ok
```

> [!important]
> Un pointeur générique de fonction à un type de retour bien définit ! **Seuls les arguments sont génériques**

#### Application
C'est au programmeur de savoir quels arguments sont à passé en param de la fonction.
- On peut imaginer une structure qui stock un pointeur de fonction générique ainsi qu'une énumération, contenant le type d'entré attendu:
```c
typedef struct{
	enum {INT, DOUBLE, STRING} argtype;
	bool (*compare)();
} comparaison;

comparaison c_int = {INT, &lt};
/**
* c_int.argtype
* c_int.compare(2,3)
*/
```

> [!note]
> Le compilateur, qui convertie initialement les arguments passé en paramètre d'une fonction si ce dernier ne sont pas du type attendu ne pourras pas le faire dans le cadre d'un pointeur générique de fonction !

```c
student_t * mergesort(student_t * class, int size, bool (*comp) (student_t, student_t));
``` 