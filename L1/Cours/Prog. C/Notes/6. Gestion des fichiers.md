## Qu'est ce qu'un fichier ?
Un fichier est un espace de stockage de donnée qui dispose des opérations:
- Lire, écrire et tronquer
	- *Après ouverture d'un fichier, toute opération de lecture ou d'écriture se fait relativement à une position courante*

## Type FILE
Type `FILE` définit par la librairie `stdio.h` et dispose d'une grande série de fonction permettant la manipulation des fichier par pointeurs.

### Fonction utilitaires

#### fopen
```c
FILE* fopen(const char* path, const char* mode);
/* "r" ouvrir en lecture seul
*  "w" ouvre en écriture seule (crée le fichier si inexistant)
*  "a" append, écrit à la fin du fichier (crée le fichier si inexistant)
*/
```
- Les opérations, s'effectuent, par défaut, en mode texte.
- La fonction renvoie NULL en cas d'erreur


#### fclose
```c
void fclose(FILE* stream);
/* stream doit être non NULL et valide
* tout fichier ouvert doit être fermé
*/
```

#### fgetc
```c
int fgetc(FILE* stream);
// Renvoie le code ASCII du caractère à la position actuelle du fichier ou EOF en cas d'erreur
// déplace la tête de lecture
```

#### fgets
```c
char * fgets(char* s, int n, FILE* stream);
// lis les caractères et les copie dans S jusqu'à:
// '\n' est lu (et copié dans s)
// la fin du fichier est rencontré
// n-1 caractères sont lu
// Renvoie NULL en cas d'erreur, s sinon
// déplace la tête de lecture
// déplace la tête de lecture
```

#### fputc
```c
int fputc(int c, FILE* stream);
// Ecrit le caracrère c à la position actuelle du fichier et renvoie la valeur ASCII du caracrère lu. Ou EOF en cas d'erreur
```

#### fprintf
```c
void fprintf(FILE * stream, const char* format, ...)
// Fonctionne comme printf
// Renvoie le nombre de caractère écrit, ou EOF en cas d'erreur.
// déplace la tête de lecture
```

#### fscanf
```c
int fscanf(FILE * stream, const char* format, ...)
// Lit dans le fihcier à la position actuelle. Renvoie le nombre de caractères lus, ou EOF en cas d'erreur
// déplace la tête de lecture
```
Exemple:
`fscanf(f, "Age: %d\n, &value)` -> Lit à la position actuelle du fichier. On attend dans le fichier à la position actuelle:
- "Age: 30\n"
- Si ce n'est pas le cas, fscanf lit 0 caractères.

#### feof
```c
int feof(FILE* stream);
// permet de tester si la tête de lecture à atteint la fin du fichier
// renvoie si si ce n'est pas le cas
// Comportement différent si le fichier finis par un saut de ligne
```

#### fseek
```c
int fseek(FILE * stream, long offset, int whence);
// Décale la tête de lecture au sein du fichier
// whence indique le pts de départ, et peut avoir que 3 valeurs
// - SEEK_SET - le début du fichier
// - SEEK_CUR - la position actuelle
// - SEEK_END - la fin du fichier
// offset peut-être négatif
```

#### ftell
```c
long ftell(FILE * stream);
// Renvoie la position actuelle du fichier
```

#### frewind
```c
void rewind(FILE* stream);
// Place la tête de lecture au début du fichier
```
### Fichiers par défauts
Trois fichiers virtuels particuliers sont ouverts de base et peuvent être utilisé pour de la redirection.
- `stdout` sortie standard. Par défaut l'écran
- `stdin` entrée standard. Par défaut le clavier
- `stderr` sortie d'erreur standard. Par défaut, l'écran
	- Redirection: `./program  > output_file  2> error_file`
	- On décale les outputs dans des fichiers différents

### Exercice
```c
void write_student(student * std, FILE * file){
	// Error control here
	fprintf(file, "%s\n", std->name);
	fprintf(file, "%s\n", std->email);
	fprintf(file, "%d\n", std->number);
	fclose(file);
}
```

```c
void read_student(student * std, FILE* file){
	// Error control here
	fscanf(file, "%[^\n]\n%s\n%d\n", std->name, std->email, &std->number);
	// %[^\n] lire un string jusqu'à rencontrer un \n
}
```