# Définition
```c
struct foo {
	int a;
	int b;
	float c;
};
```

## Les structures dans la mémoire
[[Tableau de bord étudiant/L2/Prog. C/Notes/2. Allocation dynamiqe#Allocation d’espace pour les structures]]
Les éléments de la structure sont organisé dans la mémoire dans l'ordre de leurs déclaration.
- L'adresse mémoire du premier élément est aussi l'adresse mémoire de la structure elle même
- La taille d'une structure est variable selon l'ordre des champs
	- La structure fait des arrondis pour faire commencer les différents éléments sur le bon multiple d'octet.
	  - La structure va donc faire du *padding* entre les éléments pour avoir des multiples correctes.

## Opération sur les structures
```c
int main(void){
	struct foo f = {1, 2, 3.1}; // Def explicite
	struct foo t = f;
	printf("%d", f.a);
	return EXIT_SUCCESS;
}
```

### Exercice
```c
typedef struct s_colorRGB {
	unsigned int r; //Optimisation en remplaçant pas usigned char (1 octet)
	unsigned int g;
	unsigned int b;
} s_colorRGB;

void setRedColor(s_colorRGB * c, unsigned int value){
	c->r = value;
	return;
}

int main(void){
	s_colorRGB color = {0, 0, 0};
	setRedColor(&color, 255);
	printf("(%u, %u, %u)", color.r, color.g, color.b);
	return EXIT_SUCCESS;
}
```

## Les unions
```c
union toto{
	char a;
	char s[16];
};
```
Une union ressemble à une structure mais correspond à un unique espace mémoire partagé par ces champs.
- La taille de `union` correspond à la taille de son plus grand champ.

### Exercice
```c
union u_color{
	unsigned int gray;
	s_colorRGB rgb;
	s_colorYCbCr YCbCr;
};

void setRGB(union u_color c, s_colorRGB value){
	c->rgb = value;
	return;
}

void setGray(union u_color c, unsigned int value){
	if(value > 255){
		/**/
	}
	c->gray = value;
}

int main(void){
	u_color color;
	s_colorRGB rgb_color= {123, 234, 000};
	setRGB(&color, rgb_color);
	printf("RGB From color: (%u, %u, %u)", color.rgb.r, color.rgb.g, color.rgb.b);
	setGray(&color, 123);
	printf("Gray from color: %u", color.gray);
	return EXIT_SUCCESS;
}
```

### Enumération
```c
enum direction{
	NORTH = 0;
	EAST; // 1
	SOUTH; // 2
	WEST;
}
```
On a donc ici: `EAST = NORTH + 1` 