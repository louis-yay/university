---
Reference:
  - "[[S3bis___CI_3___Adress_and_pointer.pdf]]"
  - "[[S3Bis___CI_4___Dynamic_allocation_2.pdf]]"
Date: Invalid date
Reviewed: false
---
# Pointeurs

Les pointeurs sont utilisés pour accéder à une ==adresse==:

- ==Lire== le contenue à l’adresse mémoire
- ==Ecrire== du contenue à l’adresse mémoire
- ==Transmettre une référence== à une fonction

  

### Définition

Adresse mémoire: Début d’une zone mémoire

- Référence: Adresse d’une donnée typée
    - Pointeur: Variable contenant une référence

  

### Arithmétique des pointeurs

```C
int x,y;
int j=2;
int * p_x = &x;
int k = *(p_x+j) 
// Utile pour des tableaux:
t ~= &(t[0]) ~= &t
```

  

### Pointeur générique

Noté `void*`

- Compatible avec tout les types de pointeurs
- Déréférencement impossible
- Arithmétique impossible

_NOTE: Doit être_ _==transtypé==_ _en un autre pointeur (typé)_

  

# Utilisation du tas

On utilise la fonction `void * malloc(size_t size);` pour allouer de la mémoire

- `size` représente en octet la zone réclamé
- Renvoie l’adresse de cet espace mémoire dans le tas. ==Ou== ==`NULL`== ==en cas d’échec==
- Règles d’or:
    - Toujours vérifier le contenue du retour `!= NULL`
    - Toujours utiliser la fonction `sizeof(type)` dans le paramètre `size`

  

On utilise la fonction `void free(void * ptr);` pour libérer de l’espace mémoire.

- Libère la mémoire alloué par une fonction comme `malloc` _dans le tas_
- Doit recevoir une adresse ==sur le tas== ou `NULL`

  

## Rappels sur les tableaux

Un tableau est une zone continue de mémoire, il sert à stocké les ==valeurs de même type== les unes après les autres

- Définition: `int var[n] = {val1, val2, ..., valn};`
    
    - Définition de ce type valable uniquement lors de sa définition
    - La taille du tableau doit être connu à l’avance !
    
    ```C
    int tab_size = 10;
    int tab[tab_size]; //Ne fonctionne pas 
    ```
    
- Pour palier a cette problématique, on peut utiliser la fonction `void * malloc` 
    
    ```C
    int tab_size = 10;
    int * tab = malloc(sizeof(int)*tab_size); // Ici on est correcte
    ```
    
    - ⚠️==Toujours vérifier le rendu de la fonction== ==`malloc`==
    - ==NOTE: Il n’est plus possible d’allouer directement des valeurs à la création de notre tableau en utilisant des accolades. On doit passer par une boucle for sur tout les éléments==
- Il est possible d’initialiser la zone mémoire réservé par des 0 en utilisant la fonction `calloc`
    
    ```C
    void calloc(size_t count, size_t elt_size);
    ```
    

  

### Changer la taille d’un bloc alloué

- Peut-être fait avec la fonction de bibliothèque `realloc` 
    
    ```C
    void *realloc(void *ptr, size_t newsize);
    ```
    
    - La fonction renvoie `NULL` en cas d’erreur.

  

## Bien allouer

Eviter de faire de trop nombreux appels à `malloc`

Il ne faut pas utiliser `malloc` quand:

- De nombreuses mais petites allocations (==< 32 octets==)
- Plein d’allocations mais ==peu ou pas de désallocations==

Il est possible de gérer sa mémoire soit même avec un tableau.

→ Initialisation d’un grand tableau à l’aide d’un tableau, et remplissage manuel de ce dernier.

De même pour `realloc`

Il faut éviter de faire des `realloc` pour ajouter un, ou peu d’éléments à notre espace mémoire.

- On peu imaginer faire des `realloc` en doublant à chaque coup la taille initial du stockage.
- Pour libérer l’espace, on vérifie que ==l’espace occupé est ≤ au quart de l’espace total==.

## Allocation d’espace pour les structures
[[Tableau de bord étudiant/L2/Prog. C/Notes/5. Structures]]
**Rappel sur les structures:**

```C
struct color {
	unsigned short red;
	unsigned short green;
	unsigned short blue;
};
typedef struct color color_t; //Changement du nom pour simplifier la manipulation de la struct
```

  

Une structure se doit d’avoir une taille ==fixe.==

- Une structure peut cependant contenir une autre structure:
    
    ```C
    struct pixel{
    	int i;
    	int j;
    	color_t color;
    };
    ```
    
- ❗Il est cependant ==impossible== pour une structure de se contenir elle même

### Copie de structure

Il est possible de copier une structure vers une autre variable

```C
color_t *c = malloc(sizeof(color_t));
color_t c2 = *c;
```

- ⚠️ Si une structure contient des pointeurs, ces derniers pointeurs pointerons vers ==le même espace mémoire== lors de la copie. (Les adresses sont ==inchangées==)

  

## Allocation d’espace

Une structure peut-être alloué à l’aide d’un `malloc` en utilisant la fonction `sizeof`

- Attention: somme `sizeof` des éléments de la struct ≠ `sizeof` de la struct.

L’accès aux données d’une structure dernière un pointeur se fait de la manière suivant:

- `*(m).attribut`
- `m->attribut`

### Listes chaînées

Grâce à l’allocation dynamique, on peut mettre en oeuvre des listes arbitrairement longues

```C
typedef strut cell{
	int value;
	struct cell* next;
}Cell;
```