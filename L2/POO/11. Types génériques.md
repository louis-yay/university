Un type générique est un type paramétré.

> [!error] Motivation
> ```java
> class Canevas{
> 	Dessinable[] dessinables;
>
>	 void dessiner(Ecran e){
>		 for(Dessinable d: dessinables){
>		 //...
>		 }
>	 }
> }
> ```
> Dans cet exemple on à un objet de taille statique, on ne pourra pas réutiliser la liste pour d'autres types d'objets


**On va donc créer des listes génériques**
> [!TODO] Solution simple mais unsafe
> ```java
> class Liste{
> 	Object prends(int index){/*...*/}
> 	void mets(Object d){/*...*/}
> }
> List l = new Liste();
> l.mets(new String("foo"));
> Dessinable d = (Dessinable) l.prends(0);
>```

**Pour éviter les casts unsafe, on va définir une liste générique, mais paramétré par un autre type**
> [!done] Solution
> ```java
> class Liste<T>{
> 	T prends(int index){/*...*/}
> 	void mets(T t){/**/}
>
>
>Liste<Byte> b = new Liste<>();
>Liste<Boolean> bl = new Liste<>();
> ```
> On crée listes typé, on peut utiliser par défaut les 8 types primitifs de java.

### Type générique et polymorphisme
On souhaite créer des contraintes sur les types que l'on utilise en paramètre de nos types construits. 
- Type enfant de...
- Type parent de...
- Définition de bornes, etc...

```java
class Liste<T>{
	T prends(){/**/}
	void mets(T t){/**/}
	<E extends T> void concatDe(Liste<E> l){
		for(E t: l){
			this.mets(t);
		}
	}
}
```
L'idée ici est de pouvoir concaténé 2 liste de 2 types d'objets différents, mais qui ont une relation d'héritage entre eux.
Par exemple, on veut concaténer une liste de points à une liste de forme.


### 3 contraintes sur les types génériques
1. Bivalence 
	1. `List<?>`
2. Covarience 
	1. Borne supérieur `List<? extends T>`
3. contre-variance
	1. `List<? super T>`

Une liste peut également prendre en paramétrage un autre type construit, par exemple une liste de liste d'entiers:
```java
List<List<Integer>>
```

### Interface stream
- Voir les données sous forme d'un flux
- Séquence d'éléments
	- Faire des opérations de transformation ou de filtrage (map,filter, etc...)
	- Consommation avec une opération terminal  (count, forEach, collect...)
- Les opérations intermédiaires sont **Lazy**, elles ne sont exécute que lorsque l'on a besoin.

```java
l = // liste
l.stream().filter(n -> n > 2).map(n->"v" + n); // Prédicat booléen
// Ici on transforme la liste en séquence, on ne garde que les éléments > 2, et on modifie les valeurs en ajoutant un "v" devant. 
// On peut effectuer autant de modification que voulue.

// On termine par une opération terminale:
l.stream().filter(n -> n > 2).map(n->"v" + n).forEach(v -> sout(v)); 

```

> [!example] Exemple
> ```java
> List<String> = Amy.asList("aaa","abb","acc","dd");
> l.stream().filter(s->s.startwith("a"))
> 	.map(s -> "_" + s)
> 	.limit(2)
> 	.map(String::toUpperCase) // Appel la méthode toUpperCase sur chaque elmt
> 	.forEach(System.out.println);
> //_AAA 
> //_ABB
> ```
> On peut utiliser la méthode .tolist pour transformer le stream en liste.