### 3 concepts
- **Responsabilité**: Un objet à toutes les données ou la capacité de demander à d'autre objet des données afin de réaliser ce qu'on lui demande.
- **Cohésion**: Chaque objet doit avoir une utilité propre, on préférera plusieurs objet distinct plutôt qu'un objet unique trop large
- **Couplage**: Niveau de lien entre les différents objet. Un couplage fort implique que la modification d'un objet va grandement en impacter d'autres.

### Encapsulation
On prend un objet, *compteur*:
```Java
class Compteur{
	int cpt;
	int val(){
		return cpt++;
	}
}
```
Si on a ensuite:
```Java
Compteur cpt = Compteur();
sout("cpt =" + cpt.val()); // Return 0
```
Ici l'objet compteur ne respecte pas le contract de responsabilité, il doit renvoyer l'incrément par 1 d'un nombre hors, comme la méthode effectue une post incrémentation, on a:
```Java
cpt.cpt = 5;
cpt.val() // Return 5;
```

Ici on n'a une mauvaise encapsulation, les données du compteur sont accessible.
- Si les données ne sont pas encapsulé, alors il est possible de les modifier à l’extérieur et de compromettre sa responsabilité.
On ajoutera dans la définition de notre classe:
```Java
class Compteur{
	private int cpt;
	int val(){
		return cpt++;
	}
}
```

On souhaite ensuite pouvoir définir des attributs en mode *read only* ou en *read & write* etc...
- On définit donc des setter et des getter en fonction de l'implémentation qui nous arrange

```Java
```java
// Rectangle.java
class Rectangle{
	// Propriétés de la classe:
	private double largeur;
	private double hauteur;

	void setLargeur(double largeur){
		this.largeur = largeur;
	}
	double getLargeur(){
		return largeur;
	}
	//...	
}
```

### Héritage
L'héritage permet de factoriser la définition des objets entre eux. Supposons 2 classes:
```java
class Circle{
	int x,y;
	int radius;
	void draw(){...};
}

class Rectangle{
	int x,y;
	int height, width;
	void draw(){...};
}
```
> [!info]
> On a ici une répétition de 2 attributs `x,y` (position dans l'espace de la figure) ainsi que d'une méthode `draw()`

Pour éviter ce genre de répétition, on va créer une **nouvelle classe**
```java
class Figure{
	int x,y;
	void draw(){...};
}
```

Cette **nouvelle classe** va nous servir pour factoriser les précédentes, ces dernières vont **hériter** des attributs de la classe `Figure`
```java
class Circle extends Figure{
	int radius;
	void draw(){...};
}

class Rectangle extends Figure{
	int height, width;
	void draw(){...};
}
```
> [!warning]
> On a ici une redéfinition de la méthode `draw()`.
> Un appel de cette méthode sur un objet de type `Circle` appellera la méthode définit dans la classe `Circle`, et non pas celle de `Figure`.
> - Dans le cas ou un nouvel objet (`square` par exemple) n'a pas de méthode `draw()` définit dans sa classe, alors, c'est la méthode définit dans la classe `Figure` qui sera appelé.

#### Polymorphisme
De pars la nature de l'héritage des objets, on peut effectuer des actions plus globale sur des objets qui sont de natures différentes. Car hérité d'une même super-classe
```java
Rectangle r = new Rectangle(0,0,2,3);
Circle c = new Circle(0,0,4);
Figure[] figs = new Figure[2]; // Tableau de Figure de longueur 2
figs[0] = r;
figs[1] = c;

for(Figure fig: figs){ // pour toutes les fig dans figs
	fig.draw(); // r.draw() puis c.draw()
}
```