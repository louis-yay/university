### Enum
```java
enum Color{
	BLACK(0,0,0);
	MARON(128,0,0);
	GRAY(128,128,128);
	private int red, green, blue;

	Color(int r, int g, int b){
		this.red = r;
		this.green = g;
		this.blue = blue;
	}

	public int methode(...){
		//...
	}
}
```

Une ==énumération== permet de définir des constantes utilisable dans le reste de notre code. `color.GRAY`
- On définit un ensemble d’attribut
- Equivalent à `public static final`


**On peut utiliser des méthodes par défauts sur les énums**
- `values()` -> Récupère toutes les valeurs de l'énum sous forme d'un tableau
- `ordinal()` -> Retourne l'index
- `ValueOf(String)` -> Convertit une chaîne en enum.
- Aussi, `equals` est final

### Lambda et programmation fonctionnel 
On imagine:
```java
@FunctionInterface
public interface Operation{
	public int calculer(int x, int y){
		//...
	}
}
```
Et ensuite:
```java
public class Somme implements Operation{
	@Override
	public int calculer(int x, int y){
		return x+y;
	}
}
```
On a une classe main
```java
public class Main{
	static int compute(int x, int y, Operation op){
		return op.calculer(x, y);
	}

	public static void main(...){
		System.out.println("2 + 3 = ", compute(2, 3, new Somme()));
	}
}
```

> [!example] Utilisation
> On peu se servir des `Functional Interfaces` dans les cad d'évaluation d'opérations arithmétique. 

#### Expression lambda
```java
sout(" 2 - 3 = ", compute(2, 3, (x,y) -> x-y));
```

Au lieu d'implémenter les classes `Sommes` et l'`interface` opération, on peu utiliser les *lambda expression*

