### Rappel redéfinition de Equals
![[5. Heritage#Equals]]

#### Instenceof
Il existe une méthode `instenceof` qui permet de consulter à partir de quel classe un objet à été crée
```java
if(o instenceof Point){
	// Do smth...
}
```
`instenceof` => vérifie que `o` est non `null` et de la même class que `Point`
On peut re-écrire:
```java
if(o != null){
	if(o.getClass() == thsis.getClass()){
	}
}
```

### Abstract
Supposons une situation [[5. Heritage]], on souhaite créer une classe `Forme` avec une méthode dessiner, mais qui n'a pas de définition dans la classe `Forme`.
> [!tip]
> On ne sait pas dessiner une `Forme`, on sait dessiner un `Cercle`, un `Segment`, un `Point` etc...
> ```java
> abstract void dessiner(){/*...*/}
> ```
> Il n'est ici plus possible d'appeler la méthode `dessiner` sur la classe `Forme` 
> En rendant la classe complète `abstract` il ne sera plus possible d'instancier un objet `Forme` avec `new`
#question -> Si on crée une classe abstraite, est-ce que celle-ci peu avoir des méthodes concrètes ?

### Interfaces
On a un objet `Point` et un objet `Forme` et un objet `Image`. On a les méthodes  `dessiner` dans les méthodes `Point & Image`
Une interface permet de considérer un objet comme d'un certain type, ici, on considérera les objets `Points & Image` comme des `Dessinable`
```java
interface Dessinable{
	void dessiner(){/*...*/}
}

class Point extends Forme implements Dessinable{
	Point p = new Point(/**/);
	Dessinable d = p;
}

class Image implements Dessinable{
	/**/
}
```