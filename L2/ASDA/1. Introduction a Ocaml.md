### Les expressions
Une expression est un morceau de code que l'ordinateur peu interpréter et calculer.
>[!info]
> Le langage Ocaml vérifie la cohérence des données des opérations.

#### Opérateurs:
- `+` et `+.` pour l'addition entière et réel
- `/` et `/.` pour la division entière et réel
- `*` et `*.` pour la multiplication entière et réel
- `||` ou logique
- `&&` et logique
- `=` égalité logique

### Les liaisons
- On peut effectuer des liaisons, ajouter une étiquette à une valeur.
- `let x = 4;;`.
	- Pour modifier la valeur de x il faut de nouveau faire:
	- `let x = 4*3;;`

#### Liaisons locales
- On peut définir des variables locale à nos expressions 
	- `let pi = 3.1415 in let rayon = 5.0 in 2. *. pi *. rayon`. 
	- Ici on réutilise la 'variable' rayon dans l'expression
	- On peut donc écrire: `let y = (let x=2 in 2*x)`
> [!info]
> Le format des liaisons temporaires est la suivante:
> `let nom = valeur in`


### Les fonctions

^ca3869

Pour définir une fonction on écrit la syntaxe suivante:
```ocaml
let f x y = (float_of_int x) +. y;;

// OU

let f = fun x y -> (float_of_int x) +x. y;;
``` 
-> *Une fonction qui prend un entier x, un réel y et qui calcule leur sommes.*

Un appel de cette même fonction serait donc:
```ocaml
let z = (f 3 7.2);;
```
La syntaxe Ocaml se veut sans parenthèse ni virgules, dans la définition, comme dans l'appel de fonctions.

> [!info]
> La signature des fonctions se note des args vers l'output, de gauches à droite séparé par des flèches.
> La fonction précédente aurais:
> `int -> int -> float`

> [!warning]
> Une fonction avec des types non définit prendre un type `'a`.
> Par exemple: `fun x y -> x;`
> 	Signature: `'a -> 'b -> 'a`

^cf8964


### Fonction récursives
La syntaxe de définition d'une fonction récursive est la suivante:
```ocaml
let rec fact = 
fun n -> if n = 0 then 1 else n*fact(n-1);;

```
Autre exemple:
```ocaml
let rec pgcd = 
fun n p -> if p = 0 then n else (pgcd p (n mod p));;
```
> [!tip]
> Le mot clé `rec` permet de définir des fonction récursives

### Conditions et filtrage
La syntaxe des expression conditionnelle en Ocaml sont de la forme suivante:
```ocaml
fun x -> y
if x = y then
	x
else
	y

// exemple
let f = fun x y -> if x = y then x else y;;
```

On peut aussi définit des structure  `match v with`
```ocaml
let is_vowel = fun c ->
match c with 
'a' -> true | 
'e' -> true | 
'i' -> true | 
'o' -> true | 
'u' -> true | 
'y' -> true | 
_ -> false;; (*Sortie par défaut*)
```
> [!warning]
> Les valeurs tout au long de l'expression conditionnelle se doivent d'être de même type
> `fun x y z -> if x = y then x else z` est de signature: `val f : 'a -> 'a -> 'a -> 'a = <fun>`

### Les types construits
En OCaml on peut définir un nouveau type à l’aide du mot clé `type` suivi du nom du nouveau type.

#### Produit cartésien de type existant
```ocaml
type coding = char * int;; 
```
*On imagine ici un type `tuple` qui associe un numéro avec un caractère.*
On peut ainsi définir de nouvelles variable de ces types:
```ocaml
let code_of_A: coding = ('A', int_of_char('A'));
```
> [!tip]
> Remarque : la syntaxe (nom_de_var:nom_de_type) vérifie que la variable est bien du type attendu.

#### Types sommes
Les types sommes sont des types dont toutes les valeurs possibles ont été énuméré. 
```ocaml
type day = Monday | Tuesday | Wednesday | Thrusday | Friday | Saturday | Sunday
```
> [!info]
> Chaque forme ici identifié est appelé **constructeur**.
> Par convention, les noms de constructeurs commencent par des Majuscule pour les différencier des noms de variables

On peut également utiliser les types de base comme argument des constructeurs de nos éléments de types sommes.
```ocaml
type tbm = Tram of char | Bus of int
let t = Tram('B');;
let b = Bus(31);;
```

**Le filtrage de ces données se fera s'écrira:**
```ocaml
match v with
Bus(i) -> ... |
Tram(c) -> ...
```


```ocaml
utop # let activity_name = fun (a, b, c) : string -> a;;
val activity_name : string * 'a * 'b -> string = <fun>
```

#### Types récursifs
 Les types récursifs On peut définir des types récursifs8. Un type récursif comporte au moins deux cas, donc ce sera nécessairement un type somme. L’un au moins des constructeurs aura parmi ses arguments (après le mot-clé of ) le type récursif lui-même.
```ocaml
type int_or_char_list = 
	Nil | 
	ICell of int * int_or_char_list | 
	CCell of char * int_or_char_list ;;
```