### Erreur statique et dynamique
- **Statique:** Erreur détectable à la compilation 
- **Dynamique:** Erreur détecté à l'execution 
	- Lors de cas particulier par exemple

### Gestionnaire d'erreur
En cas d'erreur en Java, le flow d'exécution est dévier vers le gestionnaire d'erreur.
Lors d'une exception, on instancie un objet.
- **Option 1:** On traite l'exception
- **Option 2:** On renvoie l'exception à l'appelant 

```java
try{    // J'essaye de faire ça
	f();
	h();
} catch(Exception e) { // En cas d'erreur j'arrête et je continue dans le catch
	// je fais ça
}
// On continue ici après
```

### Hiérarchie des Exception
Il est possible de définir de nouvelles classes d'exception qui héritent de la classe `Exception`
```
Exception
	-> MonException
	-> FooException
		-> FooBarException
```

Le `catch` permet donc de définir le type d'`Exception` que l'on souhaite attraper et traiter.
```java
try{
	f();
}catch(MonException e){
	//...
}catch(FooException e){
	//...
}
// Traitement d'erreur en fonction du type  d'exception
```

On peut simplifier cette écriture:
```java
try{
	f();
}catch(MonException | FooException e){
	// Catch MonException & FooException type
}
```

### Création d'exception
```java
class Toto{
	void f(int x) throws FooException{ 
		if(x<3){
			throw new FooException(); // lève une exception
		}
		//...
	}
}
```
Le mot clé `throws` permet d'indiquer au compilateur que cette méthode peut renvoyer une exception.


```
Object
	-> Throwable
		-> Error                (Unchecked)
		-> Exception
			-> RuntimeException (Unchecked)
```
Toutes les exception dites `Unchecked`, n'ont pas besoin d'être `catch`, elles ont pour vocation de remonter jusqu'à la `JVM` 

### Finaly
```java
try{
	//...
}catch(FooException e){

}catch(/**/){

}finaly{
	//...
}
```


